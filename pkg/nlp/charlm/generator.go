// Copyright 2020 spaGO Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package charlm

import (
	"github.com/nlpodyssey/spago/pkg/mat"
	"github.com/nlpodyssey/spago/pkg/ml/ag"
	"github.com/nlpodyssey/spago/pkg/ml/nn"
	"github.com/nlpodyssey/spago/pkg/utils"
	"strings"
)

// Generator is a character-level language model text generator.
type Generator[T mat.DType] struct {
	GeneratorConfig[T]
	model *Model[T]
}

// GeneratorConfig provides configuration settings for a Character-level Language Model Generator.
type GeneratorConfig[T mat.DType] struct {
	MaxCharacters int
	StopAtEOS     bool
	Temperature   T
}

// NewGenerator returns a new Generator.
func NewGenerator[T mat.DType](model *Model[T], config GeneratorConfig[T]) *Generator[T] {
	return &Generator[T]{
		GeneratorConfig: config,
		model:           model,
	}
}

// GenerateText returns a new sequences of text generated by the learned language model, and its log probability.
// The output text has a maximum length defined in the generator configuration.
// The text is incrementally constructed character by character, using all previously sampled characters as input
// to predict the next one.
func (m *Generator[T]) GenerateText(prefix string) (text string, logProb T) {
	if prefix == "" {
		prefix = m.model.SequenceSeparator
	}
	g := ag.NewGraph[T]()
	proc := nn.ReifyForInference(m.model, g)
	characters := make([]string, 0)
	next, prob := m.generateNext(proc, utils.SplitByRune(prefix)...)
	characters = append(characters, next)
	logProb += prob
	for i := len(prefix); i < m.MaxCharacters; i++ {
		lastChar := characters[len(characters)-1]
		if m.StopAtEOS && lastChar == m.model.SequenceSeparator {
			break
		}
		next, prob := m.generateNext(proc, lastChar)
		characters = append(characters, next)
		logProb += prob
	}
	text = prefix + strings.Join(characters, "")
	logProb /= T(len(characters))
	return
}

func (m *Generator[T]) generateNext(proc *Model[T], xs ...string) (next string, prob T) {
	lastIndex := len(xs) - 1
	prediction := proc.Forward(xs).([]ag.Node[T])[lastIndex].Value().Data() // keep the last prediction only
	index := sample(prediction, m.Temperature)
	next = m.model.Vocabulary.MustTerm(index)
	prob = prediction[index]
	return
}
